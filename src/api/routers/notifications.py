"""
ÈÄöÁü•Ë®≠ÂÆöÁÆ°ÁêÜAPI„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
"""

import os
import json
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel, EmailStr

from ..core.security import verify_api_key
from ..core.logging import get_logger

logger = get_logger(__name__)
router = APIRouter(prefix="/notifications", tags=["notifications"])

# ÈÄöÁü•Ë®≠ÂÆö
NOTIFICATION_CONFIG_FILE = "/tmp/notification_settings.json"

class NotificationSettings(BaseModel):
    email_enabled: bool = True
    email_frequency: str = "daily"  # daily, weekly, monthly, custom
    email_time: str = "09:00"  # HH:MM format
    slack_enabled: bool = False
    slack_webhook_url: Optional[str] = None
    slack_channel: Optional[str] = None
    task_reminders: bool = True
    habit_notifications: bool = True
    system_alerts: bool = True
    custom_notifications: Dict[str, Any] = {}

class NotificationManager:
    """ÈÄöÁü•ÁÆ°ÁêÜ„ÇØ„É©„Çπ"""
    
    def __init__(self):
        self.settings = self._load_settings()
        self.smtp_config = self._get_smtp_config()
    
    def _load_settings(self) -> NotificationSettings:
        """ÈÄöÁü•Ë®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø"""
        try:
            if os.path.exists(NOTIFICATION_CONFIG_FILE):
                with open(NOTIFICATION_CONFIG_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return NotificationSettings(**data)
            else:
                # „Éá„Éï„Ç©„É´„ÉàË®≠ÂÆö„Çí‰ΩúÊàê
                default_settings = NotificationSettings()
                self._save_settings(default_settings)
                return default_settings
        except Exception as e:
            logger.error(f"Error loading notification settings: {e}")
            return NotificationSettings()
    
    def _save_settings(self, settings: NotificationSettings):
        """ÈÄöÁü•Ë®≠ÂÆö„Çí‰øùÂ≠ò"""
        try:
            os.makedirs(os.path.dirname(NOTIFICATION_CONFIG_FILE), exist_ok=True)
            with open(NOTIFICATION_CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(settings.dict(), f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Error saving notification settings: {e}")
    
    def _get_smtp_config(self) -> Dict[str, str]:
        """SMTPË®≠ÂÆö„ÇíÂèñÂæó"""
        return {
            "host": os.getenv("REPORT_EMAIL_SMTP_HOST", "smtp.gmail.com"),
            "port": int(os.getenv("REPORT_EMAIL_SMTP_PORT", "587")),
            "user": os.getenv("REPORT_EMAIL_SMTP_USER", ""),
            "password": os.getenv("REPORT_EMAIL_SMTP_PASSWORD", ""),
            "from_email": os.getenv("REPORT_EMAIL_FROM", ""),
            "to_email": os.getenv("REPORT_EMAIL_TO", "")
        }
    
    def send_email_notification(self, subject: str, content: str, html_content: str = None) -> bool:
        """„É°„Éº„É´ÈÄöÁü•„ÇíÈÄÅ‰ø°"""
        if not self.settings.email_enabled:
            logger.info("Email notifications are disabled")
            return False
        
        try:
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.smtp_config["from_email"]
            msg['To'] = self.smtp_config["to_email"]
            
            # „ÉÜ„Ç≠„Çπ„ÉàÈÉ®ÂàÜ
            text_part = MIMEText(content, 'plain', 'utf-8')
            msg.attach(text_part)
            
            # HTMLÈÉ®ÂàÜÔºàÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºâ
            if html_content:
                html_part = MIMEText(html_content, 'html', 'utf-8')
                msg.attach(html_part)
            
            # SMTPÊé•Á∂ö„Å®ÈÄÅ‰ø°
            with smtplib.SMTP(self.smtp_config["host"], self.smtp_config["port"]) as server:
                server.starttls()
                server.login(self.smtp_config["user"], self.smtp_config["password"])
                server.send_message(msg)
            
            logger.info(f"Email notification sent: {subject}")
            return True
            
        except Exception as e:
            logger.error(f"Error sending email notification: {e}")
            return False
    
    def send_slack_notification(self, message: str, channel: str = None, blocks: list = None, attachments: list = None) -> bool:
        """SlackÈÄöÁü•„ÇíÈÄÅ‰ø°Ôºà„É™„ÉÉ„ÉÅ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÂØæÂøúÔºâ"""
        if not self.settings.slack_enabled or not self.settings.slack_webhook_url:
            logger.info("Slack notifications are disabled or not configured")
            return False
        
        try:
            import requests
            
            webhook_url = self.settings.slack_webhook_url
            target_channel = channel or self.settings.slack_channel
            
            payload = {
                "text": message,
                "channel": target_channel
            }
            
            # „É™„ÉÉ„ÉÅ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÂØæÂøú
            if blocks:
                payload["blocks"] = blocks
            if attachments:
                payload["attachments"] = attachments
            
            response = requests.post(webhook_url, json=payload, timeout=10)
            response.raise_for_status()
            
            logger.info(f"Slack notification sent to {target_channel}")
            return True
            
        except Exception as e:
            logger.error(f"Error sending Slack notification: {e}")
            return False
    
    def create_slack_task_blocks(self, task_data: Dict[str, Any]) -> list:
        """„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„ÉºÁî®„ÅÆSlack„Éñ„É≠„ÉÉ„ÇØ„Çí‰ΩúÊàê"""
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"üîî „Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº: {task_data.get('title', 'ÁÑ°È°å„ÅÆ„Çø„Çπ„ÇØ')}"
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*ÊúüÊó•:*\n{task_data.get('due_date', 'Êú™Ë®≠ÂÆö')}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*„Çπ„ÉÜ„Éº„Çø„Çπ:*\n{task_data.get('status', 'Êú™Ë®≠ÂÆö')}"
                    }
                ]
            }
        ]
        
        if task_data.get('content'):
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Ë©≥Á¥∞:*\n{task_data.get('content', 'Ë©≥Á¥∞„Å™„Åó')}"
                }
            })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management"
                }
            ]
        })
        
        return blocks
    
    def create_slack_habit_blocks(self, habit_data: Dict[str, Any]) -> list:
        """ÁøíÊÖ£ÈÄöÁü•Áî®„ÅÆSlack„Éñ„É≠„ÉÉ„ÇØ„Çí‰ΩúÊàê"""
        status_emoji = "‚úÖ" if habit_data.get('completed', False) else "‚ùå"
        status_text = "ÂÆå‰∫Ü" if habit_data.get('completed', False) else "Êú™ÂÆå‰∫Ü"
        
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"üìà ÁøíÊÖ£ÈÄ≤Êçó: {habit_data.get('name', 'ÁÑ°È°å„ÅÆÁøíÊÖ£')}"
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*‰ªäÊó•„ÅÆÁä∂Ê≥Å:*\n{status_emoji} {status_text}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*ÈÄ£Á∂öÊó•Êï∞:*\n{habit_data.get('streak', 0)}Êó•"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*ÈÅîÊàêÁéá:*\n{habit_data.get('completion_rate', 0)}%"
                    }
                ]
            }
        ]
        
        if habit_data.get('description'):
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Ë©≥Á¥∞:*\n{habit_data.get('description', 'Ë©≥Á¥∞„Å™„Åó')}"
                }
            })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management"
                }
            ]
        })
        
        return blocks
    
    def create_slack_system_blocks(self, alert_type: str, message: str, details: Dict[str, Any] = None) -> list:
        """„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„ÉàÁî®„ÅÆSlack„Éñ„É≠„ÉÉ„ÇØ„Çí‰ΩúÊàê"""
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"‚ö†Ô∏è „Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà: {alert_type}"
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*„É°„ÉÉ„Çª„Éº„Ç∏:*\n{message}"
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*Áô∫ÁîüÊôÇÂàª:*\n{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                    }
                ]
            }
        ]
        
        if details:
            details_text = "\n".join([f"‚Ä¢ {k}: {v}" for k, v in details.items()])
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Ë©≥Á¥∞:*\n{details_text}"
                }
            })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management"
                }
            ]
        })
        
        return blocks
    
    def send_task_reminder(self, task_data: Dict[str, Any]) -> bool:
        """„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº„ÇíÈÄÅ‰ø°"""
        if not self.settings.task_reminders:
            return False
        
        subject = f"üîî „Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº: {task_data.get('title', 'ÁÑ°È°å„ÅÆ„Çø„Çπ„ÇØ')}"
        
        content = f"""
„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº

„Çø„Çπ„ÇØÂêç: {task_data.get('title', 'ÁÑ°È°å„ÅÆ„Çø„Çπ„ÇØ')}
ÊúüÊó•: {task_data.get('due_date', 'Êú™Ë®≠ÂÆö')}
„Çπ„ÉÜ„Éº„Çø„Çπ: {task_data.get('status', 'Êú™Ë®≠ÂÆö')}

Ë©≥Á¥∞:
{task_data.get('content', 'Ë©≥Á¥∞„Å™„Åó')}

---
PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management
        """.strip()
        
        html_content = f"""
        <html>
        <body>
            <h2>üîî „Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº</h2>
            <p><strong>„Çø„Çπ„ÇØÂêç:</strong> {task_data.get('title', 'ÁÑ°È°å„ÅÆ„Çø„Çπ„ÇØ')}</p>
            <p><strong>ÊúüÊó•:</strong> {task_data.get('due_date', 'Êú™Ë®≠ÂÆö')}</p>
            <p><strong>„Çπ„ÉÜ„Éº„Çø„Çπ:</strong> {task_data.get('status', 'Êú™Ë®≠ÂÆö')}</p>
            <hr>
            <p><strong>Ë©≥Á¥∞:</strong></p>
            <p>{task_data.get('content', 'Ë©≥Á¥∞„Å™„Åó')}</p>
            <hr>
            <p><em>PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management</em></p>
        </body>
        </html>
        """
        
        # „É°„Éº„É´ÈÄÅ‰ø°
        email_sent = self.send_email_notification(subject, content, html_content)
        
        # SlackÈÄÅ‰ø°Ôºà„É™„ÉÉ„ÉÅ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºâ
        slack_blocks = self.create_slack_task_blocks(task_data)
        slack_message = f"üîî *„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº*\n*„Çø„Çπ„ÇØÂêç:* {task_data.get('title', 'ÁÑ°È°å„ÅÆ„Çø„Çπ„ÇØ')}\n*ÊúüÊó•:* {task_data.get('due_date', 'Êú™Ë®≠ÂÆö')}\n*„Çπ„ÉÜ„Éº„Çø„Çπ:* {task_data.get('status', 'Êú™Ë®≠ÂÆö')}"
        slack_sent = self.send_slack_notification(slack_message, blocks=slack_blocks)
        
        return email_sent or slack_sent
    
    def send_habit_notification(self, habit_data: Dict[str, Any]) -> bool:
        """ÁøíÊÖ£ÈÄöÁü•„ÇíÈÄÅ‰ø°"""
        if not self.settings.habit_notifications:
            return False
        
        subject = f"üìà ÁøíÊÖ£ÈÄ≤Êçó: {habit_data.get('name', 'ÁÑ°È°å„ÅÆÁøíÊÖ£')}"
        
        content = f"""
ÁøíÊÖ£ÈÄ≤ÊçóÈÄöÁü•

ÁøíÊÖ£Âêç: {habit_data.get('name', 'ÁÑ°È°å„ÅÆÁøíÊÖ£')}
‰ªäÊó•„ÅÆÁä∂Ê≥Å: {'ÂÆå‰∫Ü' if habit_data.get('completed', False) else 'Êú™ÂÆå‰∫Ü'}
ÈÄ£Á∂öÊó•Êï∞: {habit_data.get('streak', 0)}Êó•
ÈÅîÊàêÁéá: {habit_data.get('completion_rate', 0)}%

Ë©≥Á¥∞:
{habit_data.get('description', 'Ë©≥Á¥∞„Å™„Åó')}

---
PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management
        """.strip()
        
        html_content = f"""
        <html>
        <body>
            <h2>üìà ÁøíÊÖ£ÈÄ≤ÊçóÈÄöÁü•</h2>
            <p><strong>ÁøíÊÖ£Âêç:</strong> {habit_data.get('name', 'ÁÑ°È°å„ÅÆÁøíÊÖ£')}</p>
            <p><strong>‰ªäÊó•„ÅÆÁä∂Ê≥Å:</strong> {'‚úÖ ÂÆå‰∫Ü' if habit_data.get('completed', False) else '‚ùå Êú™ÂÆå‰∫Ü'}</p>
            <p><strong>ÈÄ£Á∂öÊó•Êï∞:</strong> {habit_data.get('streak', 0)}Êó•</p>
            <p><strong>ÈÅîÊàêÁéá:</strong> {habit_data.get('completion_rate', 0)}%</p>
            <hr>
            <p><strong>Ë©≥Á¥∞:</strong></p>
            <p>{habit_data.get('description', 'Ë©≥Á¥∞„Å™„Åó')}</p>
            <hr>
            <p><em>PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management</em></p>
        </body>
        </html>
        """
        
        # „É°„Éº„É´ÈÄÅ‰ø°
        email_sent = self.send_email_notification(subject, content, html_content)
        
        # SlackÈÄÅ‰ø°Ôºà„É™„ÉÉ„ÉÅ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºâ
        slack_blocks = self.create_slack_habit_blocks(habit_data)
        status_emoji = "‚úÖ" if habit_data.get('completed', False) else "‚ùå"
        slack_message = f"üìà *ÁøíÊÖ£ÈÄ≤ÊçóÈÄöÁü•*\n*ÁøíÊÖ£Âêç:* {habit_data.get('name', 'ÁÑ°È°å„ÅÆÁøíÊÖ£')}\n*‰ªäÊó•„ÅÆÁä∂Ê≥Å:* {status_emoji} {'ÂÆå‰∫Ü' if habit_data.get('completed', False) else 'Êú™ÂÆå‰∫Ü'}\n*ÈÄ£Á∂öÊó•Êï∞:* {habit_data.get('streak', 0)}Êó•\n*ÈÅîÊàêÁéá:* {habit_data.get('completion_rate', 0)}%"
        slack_sent = self.send_slack_notification(slack_message, blocks=slack_blocks)
        
        return email_sent or slack_sent
    
    def send_system_alert(self, alert_type: str, message: str, details: Dict[str, Any] = None) -> bool:
        """„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà„ÇíÈÄÅ‰ø°"""
        if not self.settings.system_alerts:
            return False
        
        subject = f"‚ö†Ô∏è „Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà: {alert_type}"
        
        content = f"""
„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà

„Ç¢„É©„Éº„Éà„Çø„Ç§„Éó: {alert_type}
„É°„ÉÉ„Çª„Éº„Ç∏: {message}
Áô∫ÁîüÊôÇÂàª: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Ë©≥Á¥∞:
{json.dumps(details or {}, ensure_ascii=False, indent=2)}

---
PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management
        """.strip()
        
        html_content = f"""
        <html>
        <body>
            <h2>‚ö†Ô∏è „Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà</h2>
            <p><strong>„Ç¢„É©„Éº„Éà„Çø„Ç§„Éó:</strong> {alert_type}</p>
            <p><strong>„É°„ÉÉ„Çª„Éº„Ç∏:</strong> {message}</p>
            <p><strong>Áô∫ÁîüÊôÇÂàª:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <hr>
            <p><strong>Ë©≥Á¥∞:</strong></p>
            <pre>{json.dumps(details or {}, ensure_ascii=False, indent=2)}</pre>
            <hr>
            <p><em>PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management</em></p>
        </body>
        </html>
        """
        
        # „É°„Éº„É´ÈÄÅ‰ø°
        email_sent = self.send_email_notification(subject, content, html_content)
        
        # SlackÈÄÅ‰ø°Ôºà„É™„ÉÉ„ÉÅ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºâ
        slack_blocks = self.create_slack_system_blocks(alert_type, message, details)
        slack_message = f"‚ö†Ô∏è *„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà*\n*„Çø„Ç§„Éó:* {alert_type}\n*„É°„ÉÉ„Çª„Éº„Ç∏:* {message}\n*ÊôÇÂàª:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        slack_sent = self.send_slack_notification(slack_message, blocks=slack_blocks)
        
        return email_sent or slack_sent

# „Ç∞„É≠„Éº„Éê„É´ÈÄöÁü•ÁÆ°ÁêÜ„Ç§„É≥„Çπ„Çø„É≥„Çπ
notification_manager = NotificationManager()

# „É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´
class NotificationResponse(BaseModel):
    success: bool
    message: str
    notification_type: str
    timestamp: str

class SettingsResponse(BaseModel):
    settings: NotificationSettings
    timestamp: str

@router.get("/settings")
async def get_notification_settings(
    _=Depends(verify_api_key)
) -> SettingsResponse:
    """ÈÄöÁü•Ë®≠ÂÆö„ÇíÂèñÂæó"""
    try:
        logger.info("Getting notification settings")
        
        return SettingsResponse(
            settings=notification_manager.settings,
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error getting notification settings: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get settings: {str(e)}")

@router.post("/settings")
async def update_notification_settings(
    settings: NotificationSettings,
    _=Depends(verify_api_key)
) -> SettingsResponse:
    """ÈÄöÁü•Ë®≠ÂÆö„ÇíÊõ¥Êñ∞"""
    try:
        logger.info("Updating notification settings")
        
        notification_manager.settings = settings
        notification_manager._save_settings(settings)
        
        return SettingsResponse(
            settings=settings,
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error updating notification settings: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update settings: {str(e)}")

@router.post("/test/email")
async def test_email_notification(
    _=Depends(verify_api_key)
) -> NotificationResponse:
    """„É°„Éº„É´ÈÄöÁü•„ÅÆ„ÉÜ„Çπ„Éà"""
    try:
        logger.info("Testing email notification")
        
        subject = "üß™ PRISM „É°„Éº„É´ÈÄöÁü•„ÉÜ„Çπ„Éà"
        content = """
„Åì„Çå„ÅØPRISM v2.0.0„ÅÆ„É°„Éº„É´ÈÄöÁü•„ÉÜ„Çπ„Éà„Åß„Åô„ÄÇ

ÈÄöÁü•„Ç∑„Çπ„ÉÜ„É†„ÅåÊ≠£Â∏∏„Å´Âãï‰Ωú„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„Åó„Åü„ÄÇ

---
PRISM v2.0.0 - Personalized Recommendation and Intelligent System for Management
        """.strip()
        
        success = notification_manager.send_email_notification(subject, content)
        
        return NotificationResponse(
            success=success,
            message="„É°„Éº„É´ÈÄöÁü•„ÉÜ„Çπ„Éà„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü" if success else "„É°„Éº„É´ÈÄöÁü•„ÉÜ„Çπ„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            notification_type="email_test",
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error testing email notification: {e}")
        raise HTTPException(status_code=500, detail=f"Email test failed: {str(e)}")

@router.post("/test/slack")
async def test_slack_notification(
    _=Depends(verify_api_key)
) -> NotificationResponse:
    """SlackÈÄöÁü•„ÅÆ„ÉÜ„Çπ„Éà"""
    try:
        logger.info("Testing Slack notification")
        
        message = "üß™ *PRISM SlackÈÄöÁü•„ÉÜ„Çπ„Éà*\nÈÄöÁü•„Ç∑„Çπ„ÉÜ„É†„ÅåÊ≠£Â∏∏„Å´Âãï‰Ωú„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„Åó„Åü„ÄÇ"
        
        success = notification_manager.send_slack_notification(message)
        
        return NotificationResponse(
            success=success,
            message="SlackÈÄöÁü•„ÉÜ„Çπ„Éà„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü" if success else "SlackÈÄöÁü•„ÉÜ„Çπ„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºàË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ",
            notification_type="slack_test",
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error testing Slack notification: {e}")
        raise HTTPException(status_code=500, detail=f"Slack test failed: {str(e)}")

@router.post("/task-reminder")
async def send_task_reminder(
    task_data: Dict[str, Any],
    _=Depends(verify_api_key)
) -> NotificationResponse:
    """„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº„ÇíÈÄÅ‰ø°"""
    try:
        logger.info("Sending task reminder")
        
        success = notification_manager.send_task_reminder(task_data)
        
        return NotificationResponse(
            success=success,
            message="„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü" if success else "„Çø„Çπ„ÇØ„É™„Éû„Ç§„É≥„ÉÄ„Éº„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            notification_type="task_reminder",
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error sending task reminder: {e}")
        raise HTTPException(status_code=500, detail=f"Task reminder failed: {str(e)}")

@router.post("/habit-notification")
async def send_habit_notification(
    habit_data: Dict[str, Any],
    _=Depends(verify_api_key)
) -> NotificationResponse:
    """ÁøíÊÖ£ÈÄöÁü•„ÇíÈÄÅ‰ø°"""
    try:
        logger.info("Sending habit notification")
        
        success = notification_manager.send_habit_notification(habit_data)
        
        return NotificationResponse(
            success=success,
            message="ÁøíÊÖ£ÈÄöÁü•„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü" if success else "ÁøíÊÖ£ÈÄöÁü•„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            notification_type="habit_notification",
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error sending habit notification: {e}")
        raise HTTPException(status_code=500, detail=f"Habit notification failed: {str(e)}")

@router.post("/system-alert")
async def send_system_alert(
    alert_type: str = Query(..., description="„Ç¢„É©„Éº„Éà„Çø„Ç§„Éó"),
    message: str = Query(..., description="„Ç¢„É©„Éº„Éà„É°„ÉÉ„Çª„Éº„Ç∏"),
    details: str = Query(default="{}", description="Ë©≥Á¥∞ÊÉÖÂ†±ÔºàJSONÔºâ"),
    _=Depends(verify_api_key)
) -> NotificationResponse:
    """„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà„ÇíÈÄÅ‰ø°"""
    try:
        logger.info(f"Sending system alert: {alert_type}")
        
        details_dict = json.loads(details) if details else {}
        success = notification_manager.send_system_alert(alert_type, message, details_dict)
        
        return NotificationResponse(
            success=success,
            message="„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü" if success else "„Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            notification_type="system_alert",
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error sending system alert: {e}")
        raise HTTPException(status_code=500, detail=f"System alert failed: {str(e)}")

@router.get("/test")
async def test_notification_system(
    _=Depends(verify_api_key)
) -> Dict[str, Any]:
    """ÈÄöÁü•„Ç∑„Çπ„ÉÜ„É†„ÅÆ„ÉÜ„Çπ„Éà"""
    try:
        logger.info("Testing notification system")
        
        # Ë®≠ÂÆöÁ¢∫Ë™ç
        settings = notification_manager.settings
        
        # „ÉÜ„Çπ„ÉàÁµêÊûú
        test_results = {
            "email_enabled": settings.email_enabled,
            "slack_enabled": settings.slack_enabled,
            "smtp_configured": bool(notification_manager.smtp_config["user"]),
            "slack_configured": bool(settings.slack_webhook_url),
            "settings_file_exists": os.path.exists(NOTIFICATION_CONFIG_FILE)
        }
        
        return {
            "status": "success",
            "test_results": test_results,
            "settings": settings.dict(),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error testing notification system: {e}")
        return {
            "status": "error",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }
